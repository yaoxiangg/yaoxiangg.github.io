<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubes Factory</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"></script>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            height: 100vh;
            font-family: 'Ubuntu', sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        .title {
            position: absolute;
            margin-left: 20px;
            color: white;
        }

        @media (min-width: 600px) {
            .menu-btns {
                position: absolute;
                top: 80px;
            }
            .mobile-menu-btns {
                display: none;
            }
        }

        @media (max-width: 600px) {
            .mobile-menu-btns {
                position: absolute;
                top: 80px;
                width: 100%;
                text-align: center;
            }
            .menu-btns {
                display: none;
            }
        }

        .btn {
            background: #ffffff;
            padding: 10px 20px;
            min-width: 80px;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .btn:active, .btn:hover {
            background: #eba601;
        }

        .btn-round {
            border-radius: 5px;
            background: #ffffff;
            display: inline-flex;
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }

        .btn-round:active, .btn-round:hover {
            background: #eba601;
        }

        .switch {
          display: inline-block;
          height: 34px;
          position: relative;
          width: 60px;
          position: absolute;
          right: 20px;
          top: 25px;
        }

        .switch input {
          display:none;
        }

        .slider {
          background-color: #ccc;
          bottom: 0;
          cursor: pointer;
          left: 0;
          position: absolute;
          right: 0;
          top: 0;
          transition: .4s;
        }

        .slider:before {
          background-color: #fff;
          bottom: 4px;
          content: "";
          height: 26px;
          left: 4px;
          position: absolute;
          transition: .4s;
          width: 26px;
        }

        input:checked + .slider {
          background-color: #66bb6a;
        }

        input:checked + .slider:before {
          transform: translateX(26px);
        }

        .slider.round {
          border-radius: 34px;
        }

        .slider.round:before {
          border-radius: 50%;
        }

        .hide {
            display: none;
        }

    </style>
</head>

<body>
    <h1 class="title hud-elem">Genique</h1>
    <label class="switch hud-elem" for="checkbox">
        <input type="checkbox" id="checkbox"/>
        <div class="slider round" onclick="toggleCycle()"></div>
    </label>
    <div class="menu-btns hud-elem">
        <div class="btn" onclick="showImage('helloworld')">你好世界</div>
        <div class="btn" onclick="showImage('cube')">CUBE</div>
        <div class="btn" onclick="showImage('snorlax')">SNORLAX</div>
        <div class="btn" onclick="showImage('dratini')">DRATINI</div>
        <div class="btn" onclick="showImage('charmander')">CHARMANDER</div>
        <div class="btn" onclick="showImage('squirtle')">SQUIRTLE</div>
        <div class="btn" onclick="showImage('bulbasaur')">BULBASAUR</div>
        <div class="btn" onclick="showImage('wallz')">WALL Z</div>
    </div>
    <div class="mobile-menu-btns hud-elem">
        <div class="btn-round" onclick="showImage('helloworld')">你好世界</div>
        <div class="btn-round" onclick="showImage('cube')">CUBE</div>
        <div class="btn-round" onclick="showImage('snorlax')">SNORLAX</div>
        <div class="btn-round" onclick="showImage('dratini')">DRATINI</div>
        <div class="btn-round" onclick="showImage('charmander')">CHARMANDER</div>
        <div class="btn-round" onclick="showImage('squirtle')">SQUIRTLE</div>
        <div class="btn-round" onclick="showImage('bulbasaur')">BULBASAUR</div>
        <div class="btn-round" onclick="showImage('wallz')">WALL Z</div>
    </div>

    <script src="./assets/js/blueprint.js"></script>
    <script>

        // Global Vars
        console.log("Hit <space> key to hide/unhide HUD");
        console.log(gsap.ticker);
        var currentTimeout = [];
        var cycle_enabled = false;
        var hide_hud = false;
        var backgroundColor = 0x061822;
        var planeColor = 0xf7f9fb;
        var cubeGaps = 1.05;

        // Cubes Grids
        var full_cube = [];
        var randomColor = Math.floor(Math.random()*16777215);
        // console.log("Random Color: 0x" + randomColor.toString(16));
        for(var j = 0; j < 10; j++){
            for(var i = 0; i < 10; i++){
                for(var k = 0; k < 10; k++){
                    full_cube.push([i,j,k,randomColor]);
                }
            }
        }

        var helloworld_grid = helloworld_1_grid.concat(helloworld_2_grid).concat(helloworld_3_grid).concat(helloworld_4_grid);
        var g_grids = [snorlax_grid,dratini_grid,imagex_grid,imagey_grid,imagez_grid,image_gengar_grid,full_cube,helloworld_grid];

        // Setup Scene
        var scene = new THREE.Scene();

        // Helper Functions
        function showImage(image_name) {
            var tl = gsap.exportRoot();
            for (var i = 0; i < currentTimeout.length; i++) {
                clearTimeout(currentTimeout[i]);
            }
            currentTimeout = [];
            gsap.to(tl, 0, {timeScale:0, onComplete:function(){ 
                tl.kill();
                if (image_name == "snorlax") { drawImage(snorlax_grid); }
                if (image_name == "dratini") { drawImage(dratini_grid); }
                if (image_name == "wallx") { drawImage(imagex_grid); }
                if (image_name == "wally") { drawImage(imagey_grid); }
                if (image_name == "wallz") { drawImage(imagez_grid); }
                if (image_name == "weird1") { drawImage(image_gengar_grid); }
                if (image_name == "cube") { drawImage(full_cube); }
                if (image_name == "helloworld") { drawImage(helloworld_grid); }
                if (image_name == "charmander") { drawImage(charmander_grid); }
                if (image_name == "squirtle") { drawImage(squirtle_grid); }
                if (image_name == "bulbasaur") { drawImage(bulbasaur_grid); }
                if (cycle_enabled) {
                    cycleImage(0);
                }
            }});
            
        }
        var is_drawing = false;
        var group = new THREE.Group();
        function drawImage(image_grid) {
            if (is_drawing) return;
            is_drawing = true;
            var idx = 0;
            var to_remove = [];
            scene.traverseVisible( function ( object ) {
                var geometry = object.geometry;
                if ( object instanceof THREE.Mesh ) {
                    if (geometry.type == 'BoxGeometry') {
                        if (idx >= image_grid.length) {
                            if (object.type !== 'Scene') {
                                to_remove.push(object);
                            }
                        } else {
                            if (idx <= image_grid.length) {
                                moveCube(object, image_grid[idx][0], image_grid[idx][1], image_grid[idx][2], image_grid[idx][3]);
                            }
                            idx += 1;
                        }
                    }
                }
            });

            for (x in to_remove) {
                removeCube(to_remove[x]);
            }

            var to_add = image_grid.length - idx;
            for (var c = 0; c < to_add; c++) {
                addCube(image_grid[idx+c][0], image_grid[idx+c][1], image_grid[idx+c][2], image_grid[idx+c][3]);
            }
            is_drawing = false;
        }

        function removeCube(cube) {
            // Fly from top
            // gsap.to(cube.position, 1, {y: cube.position.y*cubeGaps+60});
            gsap.to(cube.material, 1, { transparent: true, opacity: 0});
            gsap.to(cube.scale, 1, { x: 0.0, y: 0.0, z: 0.0, ease: Power4.easeInOut}, "-=1");
            var removetimeout = setTimeout(function() { cube.geometry.dispose(); group.remove(cube); scene.remove(cube); }, 1000);
            currentTimeout.push(removetimeout);
        }

        function addCube(x, y, z, color) {
            var color_val = new THREE.Color(color);
            var cube = drawCube(x,y,z, color);
            gsap.to(cube.scale, 1, { x: 1, y: 1, z: 1, ease: Power4.easeInOut, delay: 0.5});
            gsap.to(cube.position, 2, {x: (x-5)*cubeGaps, y: y*cubeGaps, z: (z-5)*cubeGaps, ease: Power4.easeInOut}, "-=2");
            gsap.to(cube.material, 1, { transparent: true, opacity: 1});
            return cube;
        }

        function moveCube(cube, x, y, z, color) {
            var color_val = new THREE.Color(color);
            // var duration = Math.min(2, 1.4*(1+(x/5.0+y/5.0+z/5.0)));
            var duration = 2;
            gsap.to(cube.position, duration, {x: (x-5)*cubeGaps, y: y*cubeGaps, z: (z-5)*cubeGaps, ease: Power4.easeInOut}, "-=2");
            gsap.to(cube.scale, 1, { x: 1, y: 1, z: 1,ease: Power4.easeInOut});
            gsap.to(cube.material, 1, { transparent: true, opacity: 1});
            gsap.to(cube.material.color, duration, {r: color_val.r, g: color_val.g, b: color_val.b}, "-=2");
        }

        function drawCube(x, y, z, color) {
            var geometry = new THREE.BoxGeometry(1, 1, 1);  
            var material = new THREE.MeshPhongMaterial({color: color});
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = (x-5)*cubeGaps;
            mesh.position.y = y*cubeGaps;
            mesh.position.z = (z-5)*cubeGaps;
            mesh.castShadow = true; //default is false
            mesh.receiveShadow = false; //default
            mesh.scale.x = 0.0;
            mesh.scale.y = 0.0;
            mesh.scale.z = 0.0;
            mesh.cursor = 'pointer';
            group.add(mesh);
            scene.add(group);
            return mesh;
        }

        function drawPlane(x, y, z, color) {
            const geometry = new THREE.PlaneGeometry(20,20);
            geometry.rotateX(-Math.PI * 0.5);
            const material = new THREE.MeshLambertMaterial( {color: color, side: THREE.DoubleSide} );
            const plane = new THREE.Mesh( geometry, material );
            plane.position.y = -0.5;
            plane.position.x = 0;
            plane.position.z = 0;
            plane.receiveShadow = true;
            scene.add(plane);
        }

        var aspect = window.innerWidth / window.innerHeight;
        if (aspect > 1)
            width = 60*aspect;
        else 
            width = 40;
        var height = width / aspect;

        // Setup Camera
        var camera = new THREE.OrthographicCamera(
            width / -2, // left
            width / 2, // right
            height / 2, // top
            height / -2, // bottom
            0, // near plane
            600 // far plane
        );

        camera.position.set(50, 50, 50);
        camera.lookAt(0, 0, 0);

        // Setup Renderer
        var renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);
        
        // Draw Starry Scene
        var getRandomParticlePos = (particleCount) => {
          const arr = new Float32Array(particleCount * 3);
          for (let i = 0; i < particleCount * 3; i++) {
            var rand = Math.random();
            arr[i] = (rand - 0.5) * 300;
          }
          return arr;
        };
        var geometry = new THREE.BufferGeometry().setAttribute("position", new THREE.BufferAttribute(getRandomParticlePos(1000), 3));
        var geometry2 = new THREE.BufferGeometry().setAttribute("position", new THREE.BufferAttribute(getRandomParticlePos(600), 3));
        var loader = new THREE.TextureLoader();
        var material = new THREE.PointsMaterial({ size: 1, transparent: true });
        var material2 = new THREE.PointsMaterial({ size: 3, transparent: true });
        var cube = new THREE.Points(geometry, material);
        var big_cube = new THREE.Points(geometry2, material2);
        scene.add(cube);
        scene.add(big_cube);
        renderer.setClearColor(backgroundColor); 

        // Draw Globe
        const RADIUS = 40;
        const SEGMENTS = 50;
        const RINGS = 50;
        var sphere = new THREE.SphereGeometry( RADIUS, SEGMENTS, RINGS );
        var sphere_mesh;
        loader.load( './assets/img/earth.jpg', function ( texture ) {
            var globe = new THREE.Group();
            var material = new THREE.MeshBasicMaterial( { map: texture } );
            sphere_mesh = new THREE.Mesh( sphere, material );
            globe.position.y = -RADIUS;
            globe.position.x = 0;
            globe.position.z = 0;
            globe.add(sphere_mesh);
            scene.add(globe);
        } );

        // Setup Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6, 100);
        dirLight.position.set(10, 40, 20);
        dirLight.castShadow = true; // default false
        dirLight.shadow.mapSize.width = 512*2; // default
        dirLight.shadow.mapSize.height = 512*2; // default
        dirLight.shadow.camera.near = 0; // default
        dirLight.shadow.camera.far = 100; // default
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 25;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.maxPolarAngle  = Math.PI / 2 - 0.1;
        controls.minPolarAngle  = Math.PI / 8;
        controls.maxZoom = Math.PI/ 2;
        controls.minZoom = Math.PI/ 9;
        controls.update();

        // Show Helpers
        // const axesHelper = new THREE.AxesHelper( 5 );
        // scene.add(axesHelper);
        // const helper = new THREE.CameraHelper( dirLight.shadow.camera );
        // scene.add( helper );

        // Append to DOM
        document.body.appendChild(renderer.domElement);

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        animate();

        // Detect Intersects
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var is_moving_camera = false;
        function onMouseDown(event) {
            is_moving_camera = true;
            old_x = (event.clientX / window.innerWidth) * 2 - 1;
            old_y = (event.clientY / window.innerHeight) * 2 - 1;
        }

        function onTouchStart(event) {
            is_moving_camera = true;
            mouse.x = (event.touches[0].clientX  / window.innerWidth) * 2 - 1;
            mouse.y = (event.touches[0].clientY  / window.innerHeight) * 2 - 1;
            old_x = mouse.x;
            old_y = mouse.y;
        }

        function onMouseUp(event) {
            is_moving_camera = false;
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            processMouse(mouse.x, mouse.y);
            old_x = (event.clientX / window.innerWidth) * 2 - 1;
            old_y = (event.clientY / window.innerHeight) * 2 - 1;
        }

        function onTouchMove(event) {
            mouse.x = (event.touches[0].clientX  / window.innerWidth) * 2 - 1;
            mouse.y = (event.touches[0].clientY  / window.innerHeight) * 2 - 1;
            processMouse(mouse.x, mouse.y);
            old_x = mouse.x;
            old_y = mouse.y;
        }


        var old_delta = 0;
        function processMouse(clientX, clientY) {
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children, true);

            for(var i = 0; i < intersects.length; i++) {
                var final_rot = Math.PI * 0.5;
                if (intersects[i].object.rotation.y > Math.PI * 0.5) {
                    final_rot = 0;
                }
                var xx = intersects[i].object.rotation.y + Math.PI * 0.5;
                if (intersects[i].object.geometry.type == 'BoxGeometry') {
                    this.tl = new TimelineMax();
                    this.tl.to(intersects[i].object.scale, .5, {x: .5, y: .5, z: .5,ease: Expo.easeOut});
                    this.tl.to(intersects[i].object.rotation, .5, {y: Math.PI*.5, ease: Expo.easeOut});
                    this.tl.to(intersects[i].object.scale, .5, {x: 1, y: 1, z: 1,ease: Expo.easeOut});;
                }
                break;
            }
        }
        window.addEventListener('touchstart', onTouchStart);
        window.addEventListener('touchend', onMouseUp);
        window.addEventListener('touchmove', onTouchMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            var aspect = window.innerWidth / window.innerHeight;
            if (aspect > 1) width = 60*aspect;
            else width = 40;
            var height = width / aspect;
            camera.left = width / -2;
            camera.right = width / 2;
            camera.top = height / 2;
            camera.bottom = - height / 2;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function toggleCycle() {
            if (cycle_enabled) {
                for (var i = 0; i < currentTimeout.length; i++) {
                    clearTimeout(currentTimeout[i]);
                }
                currentTimeout = [];
            } else {
                cycleImage(0);
            }
            cycle_enabled = !cycle_enabled;
        }

        // Keyboards
        function setupKeyControls() {
          document.onkeydown = function(e) {
          var cube = group;
            switch (e.keyCode) {
                case 87: //w
                    break;
                // case 83: //s
                // case 65: //a
                // case 68: //d
                case 65:
                    gsap.to(cube.rotation, {y: cube.rotation.y+0.5, ease: Power4.easeInOut});
                    break;
                case 68:
                    gsap.to(cube.rotation, {y: cube.rotation.y-0.5, ease: Power4.easeInOut});
                    break;
                case 32: // space
                    var hud_elems = document.querySelectorAll('.hud-elem');
                    for (var i = 0; i < hud_elems.length; i++) {
                        if (hide_hud) {
                            hud_elems[i].classList.add("hide");
                        } else {
                            hud_elems[i].classList.remove("hide");
                        }
                    }
                    hide_hud = !hide_hud;
                    break;
            }
          };
        }
        setupKeyControls();

        // Script after Init

        // Draw Initial Plane and Cubes
        // drawPlane(0,0,0,planeColor);

        function cycleImage(img) {
            var timeout_ms = 4000;
            if (img == -1) {
                timeout_ms = 0;
                img = 0;
            } 
            var timeout = setTimeout(function() {
                drawImage(g_grids[img]) 
                if (cycle_enabled)
                    cycleImage((img + 1) % g_grids.length);
            }, timeout_ms);
            currentTimeout.push(timeout);
        }
        
        cycleImage(-1);

    </script>
</body>
</html>
