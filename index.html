<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            height: 100vh;
            font-family: 'Ubuntu', sans-serif;
        }

        canvas {
            display: block;
        }

        h1 {
            position: absolute;
            color: #d1d1e0;
            top: 2.5em;
            left: 4em;
            font-size: 3.5em;
            width: auto;
            line-height: .8em;
            padding: .2em;
        }

        p {
            position: absolute;
            color: #d1d1e0;
            top: 50%;
            left: 50%;
            font-size: 1.8em;
            width: auto;
            line-height: .8em;
            padding: .2em;
        }

        #span button {
            font-size: .8em;
            padding: 15px;
        }
    </style>
</head>

<body>
    <h1 class="shadow-lg p-5 mb-5 rounded">Genique</h1>

    <script>

        // Global Vars
        var backgroundColor = 0x333333;
        var planeColor = 0x80cbc4;

        var imagey_grid = [[0,0,0,0x61c6f6],[0,1,0,0x61c6f6],[0,2,0,0x61c6f6],[0,3,0,0x61c6f6],[0,4,0,0x61c6f6],[0,5,0,0x61c6f6],[0,6,0,0x61c6f6],[0,7,0,0x61c6f6],[0,8,0,0x61c6f6],[0,9,0,0x61c6f6],[0,10,0,0x61c6f6]];

        var imagex_grid = [[0,0,0,0xdd6780],[1,0,0,0xdd6780],[2,0,0,0xdd6780],[3,0,0,0xdd6780],[4,0,0,0xdd6780],[5,0,0,0xdd6780],[6,0,0,0xdd6780],[7,0,0,0xdd6780],[8,0,0,0xdd6780],[9,0,0,0xdd6780],[10,0,0,0xdd6780]];

        var imagez_grid = [[0,0,0,0x777ed2],[0,0,1,0x777ed2],[0,0,2,0x777ed2],[0,0,3,0x777ed2],[0,0,4,0x777ed2],[0,0,5,0x777ed2],[0,0,6,0x777ed2],[0,0,7,0x777ed2],[0,0,8,0x777ed2],[0,0,9,0x777ed2],[0,0,10,0x777ed2],[0,1,10,0x777ed2],[0,1,9,0x777ed2],[0,1,8,0x777ed2],[0,1,7,0x777ed2],[0,1,6,0x777ed2],[0,1,5,0x777ed2],[0,1,4,0x777ed2],[0,1,3,0x777ed2]];


        var scene = new THREE.Scene();

        // Helper Functions
        function drawImage(image_grid) {
            var idx = 0;
            var to_remove = [];
            scene.traverseVisible( function ( object ) {
                var geometry = object.geometry;
                if ( object instanceof THREE.Mesh ) {
                    if (geometry.type == 'BoxGeometry') {
                        if (idx >= image_grid.length) {
                            if (object.type !== 'Scene') {
                                to_remove.push(object);
                            }
                        } else {
                            if (idx <= image_grid.length) {
                                moveCube(object, image_grid[idx][0], image_grid[idx][1], image_grid[idx][2], image_grid[idx][3]);
                            }
                            idx += 1;
                        }
                    }
                }
            });

            for (x in to_remove) {
                removeCube(to_remove[x]);
            }

            var to_add = image_grid.length - idx;
            for (var c = 0; c < to_add; c++) 
                addCube(image_grid[idx+c][0], image_grid[idx+c][1], image_grid[idx+c][2], image_grid[idx+c][3]);
        }

        function removeCube(cube) {
            this.tl = new TimelineMax();
            this.tl.to(cube.position, 1, {y: cube.position.y*1.2+40, ease: Expo.easeOut});
            setTimeout(function() { scene.remove(cube); }, 1500);
        }

        function addCube(x, y, z, color) {
            var cube = drawCube(x,y+50,z, color);
            moveCube(cube, x, y, z, color);
        }

        function moveCube(cube, x, y, z, color) {
            var color_val = new THREE.Color(color);
            this.tl = new TimelineMax();
            this.tl.to(cube.position, 1.2*(1+(x/5.0+y/5.0+z/5.0)), {x: (x-5)*1.2, y: y*1.2, z: (z-5)*1.2, ease: Expo.easeOut});
            this.tl.to(cube.material.color, 1.2*(1+(x/5.0+y/5.0+z/5.0)), {r: color_val.r, g: color_val.g, b: color_val.b, ease: Expo.easeOut}, "-=2");
        }

        function drawCube(x, y, z, color) {
            var geometry = new THREE.BoxGeometry(1, 1, 1);  
            var material = new THREE.MeshLambertMaterial({color: color});
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = (x-5)*1.2;
            mesh.position.y = y*1.2;
            mesh.position.z = (z-5)*1.2;
            mesh.castShadow = true; //default is false
            mesh.receiveShadow = false; //default
            scene.add(mesh);
            return mesh;
        }

        function drawPlane(x, y, z, color) {
            const geometry = new THREE.PlaneGeometry(20,20);
            geometry.rotateX(-Math.PI * 0.5); // this is how you can do it
            const material = new THREE.MeshStandardMaterial( {color: color, side: THREE.DoubleSide} );
            const plane = new THREE.Mesh( geometry, material );
            plane.position.y = -1.2;
            plane.position.x = 0;
            plane.position.z = 0;
            plane.receiveShadow = true;
            scene.add(plane);
        }

        const aspect = window.innerWidth / window.innerHeight;
        const width = 50;
        const height = width / aspect;

        // Setup Camera
        var camera = new THREE.OrthographicCamera(
            width / -2, // left
            width / 2, // right
            height / 2, // top
            height / -2, // bottom
            0, // near plane
            200 // far plane
        );
        camera.position.set(40, 40, 50);
        camera.lookAt(0, 0, 0);

        // Setup Renderer
        var renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);
        renderer.setClearColor(backgroundColor); 

        // Setup Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6, 100);
        dirLight.position.set(10, 20, 0);
        dirLight.castShadow = true; // default false
        dirLight.shadow.mapSize.width = 512; // default
        dirLight.shadow.mapSize.height = 512; // default
        dirLight.shadow.camera.near = 0.5; // default
        dirLight.shadow.camera.far = 500; // default
        scene.add(dirLight);

        // Show Light Camera Grid
        // const helper = new THREE.CameraHelper( dirLight.shadow.camera );
        // scene.add( helper );

        // Append to DOM
        document.body.appendChild(renderer.domElement);

        var render = function(){
            requestAnimationFrame(render);
            renderer.render(scene,camera);
        };
        render();

        // Detect Intersects
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        function onMouseMove(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children, true);

            for(var i = 0; i < intersects.length; i++) {
                if (intersects[i].object.geometry.type != 'PlaneGeometry') {
                    this.tl = new TimelineMax();
                    this.tl.to(intersects[i].object.scale, .5, {x: .5, y: .5, z: .5,ease: Expo.easeOut});
                    this.tl.to(intersects[i].object.rotation, .5, {y: Math.PI*.5, ease: Expo.easeOut});
                    this.tl.to(intersects[i].object.scale, .5, {x: 1, y: 1, z: 1,ease: Expo.easeOut});
                }
            }
        }
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth,window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });


        // Script after Init

        // Draw Initial Plane and Cubes
        drawPlane(0,0,0,planeColor);
        var randomColor = Math.floor(Math.random()*16777215);
        console.log("Random Color: 0x" + randomColor.toString(16));
        for(var j = 0; j < 3; j++){
            for(var i = 0; i < 4; i++){
                for(var k = 0; k < 4; k++){
                    addCube(i,j,k,randomColor);
                }
            }
        }

        function cycleImage(img) {
            setTimeout(function() {
                if (img == 0)
                    drawImage(imagex_grid) 
                if (img == 1)
                    drawImage(imagey_grid) 
                if (img == 2)
                    drawImage(imagez_grid) 
                cycleImage((img + 1)% 3);
            }, 3000);
        }
        
        cycleImage(0);

    </script>
</body>
</html>
