<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubes Factory</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"></script>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            height: 100vh;
            font-family: 'Ubuntu', sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        .title {
            position: absolute;
            margin-left: 20px;
            color: white;
        }

        @media (min-width: 600px) {
            .menu-btns {
                position: absolute;
                top: 80px;
            }
            .mobile-menu-btns {
                display: none;
            }
        }

        @media (max-width: 600px) {
            .mobile-menu-btns {
                position: absolute;
                top: 80px;
                width: 100%;
                text-align: center;
            }
            .menu-btns {
                display: none;
            }
        }

        .btn {
            background: #ffffff;
            padding: 10px 20px;
            min-width: 80px;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .btn:active, .btn:hover {
            background: #eba601;
        }

        .btn-round {
            border-radius: 5px;
            background: #ffffff;
            display: inline-flex;
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }

        .btn-round:active, .btn-round:hover {
            background: #eba601;
        }

        .switch {
          display: inline-block;
          height: 34px;
          position: relative;
          width: 60px;
          position: absolute;
          right: 20px;
          top: 25px;
        }

        .switch input {
          display:none;
        }

        .slider {
          background-color: #ccc;
          bottom: 0;
          cursor: pointer;
          left: 0;
          position: absolute;
          right: 0;
          top: 0;
          transition: .4s;
        }

        .slider:before {
          background-color: #fff;
          bottom: 4px;
          content: "";
          height: 26px;
          left: 4px;
          position: absolute;
          transition: .4s;
          width: 26px;
        }

        input:checked + .slider {
          background-color: #66bb6a;
        }

        input:checked + .slider:before {
          transform: translateX(26px);
        }

        .slider.round {
          border-radius: 34px;
        }

        .slider.round:before {
          border-radius: 50%;
        }


    </style>
</head>

<body>
    <h1 class="title">Genique</h1>
    <label class="switch" for="checkbox">
        <input type="checkbox" id="checkbox" checked/>
        <div class="slider round" onclick="toggleCycle()"></div>
    </label>
    <div class="menu-btns">
        <div class="btn" onclick="showImage('helloworld')">你好世界</div>
        <div class="btn" onclick="showImage('cube')">CUBE</div>
        <div class="btn" onclick="showImage('snorlax')">SNORLAX</div>
        <div class="btn" onclick="showImage('dratini')">DRATINI</div>
        <div class="btn" onclick="showImage('wallx')">WALL X</div>
        <div class="btn" onclick="showImage('wally')">WALL Y</div>
        <div class="btn" onclick="showImage('wallz')">WALL Z</div>
        <div class="btn" onclick="showImage('weird1')">WEIRD 1</div>
    </div>
    <div class="mobile-menu-btns">
        <div class="btn-round" onclick="showImage('helloworld')">你好世界</div>
        <div class="btn-round" onclick="showImage('cube')">CUBE</div>
        <div class="btn-round" onclick="showImage('snorlax')">SNORLAX</div>
        <div class="btn-round" onclick="showImage('dratini')">DRATINI</div>
        <div class="btn-round" onclick="showImage('wallx')">WALL X</div>
        <div class="btn-round" onclick="showImage('wally')">WALL Y</div>
        <div class="btn-round" onclick="showImage('wallz')">WALL Z</div>
        <div class="btn-round" onclick="showImage('weird1')">WEIRD 1</div>
    </div>

    <script src="./assets/js/blueprint.js"></script>
    <script>

        // Global Vars
        console.log(gsap.ticker);
        var currentTimeout = [];
        var cycle_enabled = true;
        var backgroundColor = 0x707070;
        var planeColor = 0xf7f9fb;
        var cubeGaps = 1.05;

        // Cubes Grids
        var full_cube = [];
        var randomColor = Math.floor(Math.random()*16777215);
        // console.log("Random Color: 0x" + randomColor.toString(16));
        for(var j = 0; j < 10; j++){
            for(var i = 0; i < 10; i++){
                for(var k = 0; k < 10; k++){
                    full_cube.push([i,j,k,randomColor]);
                }
            }
        }

        var helloworld_grid = helloworld_1_grid.concat(helloworld_2_grid).concat(helloworld_3_grid).concat(helloworld_4_grid);
        var g_grids = [snorlax_grid,dratini_grid,imagex_grid,imagey_grid,imagez_grid,image_gengar_grid,full_cube,helloworld_grid];

        // Setup Scene
        var scene = new THREE.Scene();

        // Helper Functions
        function showImage(image_name) {
            var tl = gsap.exportRoot();
            for (var i = 0; i < currentTimeout.length; i++) {
                clearTimeout(currentTimeout[i]);
            }
            currentTimeout = [];
            gsap.to(tl, 0, {timeScale:0, onComplete:function(){ 
                tl.kill();
                if (image_name == "snorlax") { drawImage(snorlax_grid); }
                if (image_name == "dratini") { drawImage(dratini_grid); }
                if (image_name == "wallx") { drawImage(imagex_grid); }
                if (image_name == "wally") { drawImage(imagey_grid); }
                if (image_name == "wallz") { drawImage(imagez_grid); }
                if (image_name == "weird1") { drawImage(image_gengar_grid); }
                if (image_name == "cube") { drawImage(full_cube); }
                if (image_name == "helloworld") { drawImage(helloworld_grid); }
                if (cycle_enabled) {
                    cycleImage(0);
                }
            }});
            
        }
        function drawImage(image_grid) {
            var idx = 0;
            var to_remove = [];
            scene.traverseVisible( function ( object ) {
                var geometry = object.geometry;
                if ( object instanceof THREE.Mesh ) {
                    if (geometry.type == 'BoxGeometry') {
                        if (idx >= image_grid.length) {
                            if (object.type !== 'Scene') {
                                to_remove.push(object);
                            }
                        } else {
                            if (idx <= image_grid.length) {
                                moveCube(object, image_grid[idx][0], image_grid[idx][1], image_grid[idx][2], image_grid[idx][3]);
                            }
                            idx += 1;
                        }
                    }
                }
            });

            for (x in to_remove) {
                removeCube(to_remove[x]);
            }

            var to_add = image_grid.length - idx;
            for (var c = 0; c < to_add; c++) 
                addCube(image_grid[idx+c][0], image_grid[idx+c][1], image_grid[idx+c][2], image_grid[idx+c][3]);
        }

        function removeCube(cube) {
            gsap.to(cube.position, 1, {y: cube.position.y*cubeGaps+60, ease: Expo.easeOut});
            gsap.to(cube.material, 1, { transparent: true, opacity: 0, ease: Expo.easeOut}, "-=1");
            var removetimeout = setTimeout(function() { scene.remove(cube); }, 1500);
            currentTimeout.push(removetimeout);
        }

        function addCube(x, y, z, color) {
            var cube = drawCube(x,y+60,z, color);
            moveCube(cube, x, y, z, color);
        }

        function moveCube(cube, x, y, z, color) {
            var color_val = new THREE.Color(color);
            var duration = Math.min(2, 1.4*(1+(x/5.0+y/5.0+z/5.0)));
            gsap.to(cube.material, 0, { transparent: true, opacity: 1, ease: Expo.easeOut});
            gsap.to(cube.position, duration, {x: (x-5)*cubeGaps, y: y*cubeGaps, z: (z-5)*cubeGaps, ease: Expo.easeOut});
            gsap.to(cube.material.color, duration, {r: color_val.r, g: color_val.g, b: color_val.b, ease: Expo.easeOut}, "-=2");
        }

        function drawCube(x, y, z, color) {
            var geometry = new THREE.BoxGeometry(1, 1, 1);  
            var material = new THREE.MeshPhongMaterial({color: color});
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = (x-5)*cubeGaps;
            mesh.position.y = y*cubeGaps;
            mesh.position.z = (z-5)*cubeGaps;
            mesh.castShadow = true; //default is false
            mesh.receiveShadow = false; //default
            scene.add(mesh);
            mesh.cursor = 'pointer';
            return mesh;
        }

        function drawPlane(x, y, z, color) {
            const geometry = new THREE.PlaneGeometry(20,20);
            geometry.rotateX(-Math.PI * 0.5);
            const material = new THREE.MeshLambertMaterial( {color: color, side: THREE.DoubleSide} );
            const plane = new THREE.Mesh( geometry, material );
            plane.position.y = -0.5;//cubeGaps;
            plane.position.x = 0;
            plane.position.z = 0;
            plane.receiveShadow = true;
            scene.add(plane);
        }

        var aspect = window.innerWidth / window.innerHeight;
        if (aspect > 1)
            width = 60*aspect;
        else 
            width = 40;
        var height = width / aspect;

        // Setup Camera
        var camera = new THREE.OrthographicCamera(
            width / -2, // left
            width / 2, // right
            height / 2, // top
            height / -2, // bottom
            0, // near plane
            200 // far plane
        );

        camera.position.set(50, 50, 50);
        camera.lookAt(0, 0, 0);

        // Setup Renderer
        var renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);
        renderer.setClearColor(backgroundColor); 

        // Setup Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6, 100);
        dirLight.position.set(10, 40, 20);
        dirLight.castShadow = true; // default false
        dirLight.shadow.mapSize.width = 512*2; // default
        dirLight.shadow.mapSize.height = 512*2; // default
        dirLight.shadow.camera.near = 0; // default
        dirLight.shadow.camera.far = 100; // default
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 25;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.maxPolarAngle  = Math.PI / 2 - 0.1;
        controls.minPolarAngle  = Math.PI / 8;
        controls.maxZoom = Math.PI/ 2;
        controls.minZoom = Math.PI/ 8;
        controls.update();

        // Show Helpers
        // const axesHelper = new THREE.AxesHelper( 5 );
        // scene.add(axesHelper);
        // const helper = new THREE.CameraHelper( dirLight.shadow.camera );
        // scene.add( helper );

        // Append to DOM
        document.body.appendChild(renderer.domElement);

        function render(){
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        };
        requestAnimationFrame(render);

        // Detect Intersects
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var is_moving_camera = false;
        function onMouseDown(event) {
            is_moving_camera = true;
            old_x = (event.clientX / window.innerWidth) * 2 - 1;
            old_y = (event.clientY / window.innerHeight) * 2 - 1;
        }

        function onTouchStart(event) {
            is_moving_camera = true;
            mouse.x = (event.touches[0].clientX  / window.innerWidth) * 2 - 1;
            mouse.y = (event.touches[0].clientY  / window.innerHeight) * 2 - 1;
            old_x = mouse.x;
            old_y = mouse.y;
        }

        function onMouseUp(event) {
            is_moving_camera = false;
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            processMouse(mouse.x, mouse.y);
            old_x = (event.clientX / window.innerWidth) * 2 - 1;
            old_y = (event.clientY / window.innerHeight) * 2 - 1;
        }

        function onTouchMove(event) {
            mouse.x = (event.touches[0].clientX  / window.innerWidth) * 2 - 1;
            mouse.y = (event.touches[0].clientY  / window.innerHeight) * 2 - 1;
            processMouse(mouse.x, mouse.y);
            old_x = mouse.x;
            old_y = mouse.y;
        }


        var old_delta = 0;
        function processMouse(clientX, clientY) {
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children, true);

            for(var i = 0; i < intersects.length; i++) {
                if (intersects[i].object.geometry.type == 'BoxGeometry') {
                    gsap.to(intersects[i].object.rotation, 1, {y: Math.PI*.5, ease: Expo.easeOut});
                }
                return;
            }
        }
        window.addEventListener('touchstart', onTouchStart);
        window.addEventListener('touchend', onMouseUp);
        window.addEventListener('touchmove', onTouchMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            var aspect = window.innerWidth / window.innerHeight;
            if (aspect > 1) width = 60*aspect;
            else width = 40;
            var height = width / aspect;
            camera.left = width / -2;
            camera.right = width / 2;
            camera.top = height / 2;
            camera.bottom = - height / 2;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function toggleCycle() {
            if (cycle_enabled) {
                for (var i = 0; i < currentTimeout.length; i++) {
                    clearTimeout(currentTimeout[i]);
                }
                currentTimeout = [];
            } else {
                cycleImage(0);
            }
            cycle_enabled = !cycle_enabled;
        }
        // Script after Init

        // Draw Initial Plane and Cubes
        drawPlane(0,0,0,planeColor);

        function cycleImage(img) {
            var timeout_ms = 4000;
            if (img == -1) {
                timeout_ms = 0;
                img = 0;
            } 
            var timeout = setTimeout(function() {
                drawImage(g_grids[img]) 
                cycleImage((img + 1) % g_grids.length);
            }, timeout_ms);
            currentTimeout.push(timeout);
        }
        
        cycleImage(-1);

    </script>
</body>
</html>
